<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RoomShop</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .drawer { transition: transform 0.25s ease; }
    .drawer.closed { transform: translateX(100%); }
  </style>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  </head>
<body class="bg-gray-950 text-gray-100 min-h-screen">
  <div class="max-w-xl mx-auto p-4">
    <header class="flex items-center justify-between gap-2">
      <h1 class="text-2xl font-semibold">RoomShop</h1>
      <a href="/health" target="_blank" class="text-xs underline opacity-70">health</a>
    </header>

    <!-- Camera -->
    <section class="mt-4 space-y-3">
      <div id="frameBox" class="rounded-2xl overflow-hidden bg-black aspect-[3/4] md:aspect-[16/9] relative">
        <video id="cam" playsinline autoplay class="w-full h-full object-cover"></video>
        <canvas id="snap" class="hidden"></canvas>
        <!-- Composite overlay in center -->
        <div id="compositeOverlay" class="absolute inset-0 hidden items-center justify-center">
          <img id="compositeImg" class="max-h-full max-w-full object-contain" alt="Composite" />
        </div>
        <div class="absolute bottom-2 right-2 flex gap-2">
          <button id="btnSnap" class="px-3 py-2 bg-white/80 text-black rounded-xl">Snap</button>
          <label class="px-3 py-2 bg-white/20 rounded-xl cursor-pointer">Upload
            <input id="fileInput" type="file" accept="image/*" class="hidden" />
          </label>
        </div>
      </div>

      <textarea id="desc" class="w-full p-3 rounded-xl bg-white/10" rows="3" placeholder="Describe what you want (e.g., â€˜modern floor lamp in brassâ€™)"></textarea>

      <div class="flex items-center gap-3">
        <input id="budget" type="number" min="10" step="5" class="p-3 rounded-xl bg-white/10 w-40" placeholder="Budget (USD)" />
        <label class="flex items-center gap-2 text-sm opacity-90 select-none">
          <input id="toggleImages" type="checkbox" checked />
          Images
        </label>
        <button id="btnFind" class="ml-auto px-4 py-2 rounded-xl bg-emerald-500 text-black font-medium">Find options</button>
      </div>

      <div class="flex gap-2 items-center">
        <button id="btnVoice" class="px-3 py-2 rounded-xl bg-white/10">ðŸŽ¤ Hold to speak</button>
        <span id="voiceHint" class="text-sm opacity-70"></span>
      </div>

      <!-- Refine controls (shown after first results) -->
      <div id="refineSection" class="mt-3 hidden">
        <div class="flex gap-2 items-center">
          <input id="refineInput" class="flex-1 p-3 rounded-xl bg-white/10" placeholder="Refine (e.g., 'more Scandinavian, add shelving; pricier lamp, cheaper shelves')" />
          <button id="btnRefine" class="px-4 py-2 rounded-xl bg-white/10">Refine</button>
        </div>
      </div>
    </section>

    <!-- Bottom control bar (mobile) -->
    <section id="bottomBar" class="fixed left-0 right-0 bottom-0 hidden z-40">
      <div class="max-w-xl mx-auto p-3">
        <div class="flex items-center gap-2 bg-white/10 backdrop-blur rounded-2xl px-2 py-2">
          <button id="btnCamera" class="px-3 py-2 rounded-xl bg-white/10">ðŸ“·</button>
          <button id="btnVoiceBar" class="px-3 py-2 rounded-xl bg-white/10">ðŸŽ¤</button>
          <div class="flex gap-2 ml-auto">
            <button data-tier="low" class="tierBtn px-3 py-2 rounded-xl bg-white/10">Low</button>
            <button data-tier="mid" class="tierBtn px-3 py-2 rounded-xl bg-white/10">Mid</button>
            <button data-tier="high" class="tierBtn px-3 py-2 rounded-xl bg-white/10">High</button>
          </div>
        </div>
      </div>
    </section>


    <!-- Drawer (kept for product-only flow) -->
    <aside id="drawer" class="drawer closed fixed top-0 right-0 w-full max-w-md h-full bg-gray-900/95 backdrop-blur p-4 overflow-y-auto">
      <div class="flex items-center justify-between gap-2">
        <h2 class="text-xl font-medium">Visuals</h2>
        <div class="ml-auto flex items-center gap-2">
          <button id="finalizeDrawer" class="px-3 py-1.5 rounded-xl bg-emerald-500 text-black text-sm">Finalize</button>
          <button id="reorganizeDrawer" class="px-3 py-1.5 rounded-xl bg-white/10 text-sm">Reorganize</button>
          <button id="drawerClose" class="text-sm opacity-70">Close</button>
        </div>
      </div>
      <div id="images" class="mt-3 grid gap-3"></div>
    </aside>

    <button id="drawerOpen" class="fixed right-3 top-1/2 -translate-y-1/2 px-2 py-1 rounded-l-xl bg-white/10">â–¸</button>
  </div>

  <!-- Product modal -->
  <div id="productModal" class="fixed inset-0 hidden z-50">
    <div class="absolute inset-0 bg-black/60"></div>
    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[92vw] max-w-md max-h-[70vh] bg-gray-900 rounded-2xl p-3 overflow-hidden">
      <div class="flex items-center justify-between mb-2">
        <div class="text-sm opacity-80" id="productModalTitle">Products</div>
        <button id="productModalClose" class="text-sm opacity-70">Close</button>
      </div>
      <div id="productModalBody" class="overflow-y-auto space-y-2 pr-1"></div>
    </div>
  </div>

  <!-- 3D viewer modal -->
  <div id="modelModal" class="fixed inset-0 hidden z-50">
    <div class="absolute inset-0 bg-black/60"></div>
    <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[92vw] max-w-lg bg-gray-900 rounded-2xl p-3 overflow-hidden">
      <div class="flex items-center justify-between mb-2">
        <div class="text-sm opacity-80">3D View</div>
        <button id="modelModalClose" class="text-sm opacity-70">Close</button>
      </div>
      <model-viewer id="modelViewer" camera-controls style="width:100%; height:60vh; background:#111" autoplay></model-viewer>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loading" class="fixed inset-0 hidden items-center justify-center bg-black/60 z-50">
    <div class="flex items-center gap-3 bg-white text-black px-4 py-3 rounded-xl shadow">
      <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
      </svg>
      <span id="loadingText" class="text-sm">Loading...</span>
    </div>
  </div>

  <script>
    // --- camera ---
    const video = document.getElementById('cam');
    const canvas = document.getElementById('snap');
    async function startCam() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        video.srcObject = stream;
        video.classList.remove('hidden');
      } catch (e) { console.warn('camera error', e); }
    }
    function stopCam() {
      try {
        const s = video.srcObject;
        if (s && s.getTracks) s.getTracks().forEach(t => t.stop());
      } catch {}
      video.srcObject = null;
    }
    startCam();

    function captureImageFromVideo() {
      const vw = video.videoWidth, vh = video.videoHeight;
      if (!vw || !vh) return null;
      // Target aspect ratio matches the visible frame box (responsive)
      const frame = document.getElementById('frameBox');
      const fw = frame?.clientWidth || 3;
      const fh = frame?.clientHeight || 4;
      const desired = fw / fh; // width/height
      let cw = vw, ch = Math.round(vw / desired);
      if (ch > vh) { ch = vh; cw = Math.round(vh * desired); }
      const sx = Math.floor((vw - cw) / 2);
      const sy = Math.floor((vh - ch) / 2);
      canvas.width = cw; canvas.height = ch;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, sx, sy, cw, ch, 0, 0, cw, ch);
      return new Promise((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.92));
    }

    const fileInput = document.getElementById('fileInput');
    let spaceBlob = null;
    let selectedTier = null;
    let tierProductsUsed = { low: [], mid: [], high: [] };
    let philosophyByTier = null;

    document.getElementById('btnSnap').onclick = async () => {
      spaceBlob = await captureImageFromVideo();
      toast('Photo captured');
      try {
        const url = URL.createObjectURL(spaceBlob);
        const img = document.getElementById('compositeImg');
        img.src = url;
        document.getElementById('compositeOverlay').classList.remove('hidden');
        // Ensure live camera is not visible underneath
        stopCam();
        video.classList.add('hidden');
      } catch {}
    };
    fileInput.onchange = (e) => {
      spaceBlob = e.target.files[0];
      toast('Photo selected');
      try {
        const url = URL.createObjectURL(spaceBlob);
        const img = document.getElementById('compositeImg');
        img.src = url;
        document.getElementById('compositeOverlay').classList.remove('hidden');
        // Ensure live camera is not visible underneath
        stopCam();
        video.classList.add('hidden');
      } catch {}
    };

    // --- voice to text ---
    const btnVoice = document.getElementById('btnVoice');
    const hint = document.getElementById('voiceHint');
    let mediaRecorder, chunks = [];

    const startRecording = async () => {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      chunks = [];
      mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const fd = new FormData();
        fd.append('audio', blob, 'audio.webm');
        setLoading(true, 'Transcribing...');
        const r = await fetch('/api/stt', { method: 'POST', body: fd });
        const j = await r.json();
        setLoading(false);
        if (j.text) {
          const d = document.getElementById('desc');
          if (d) d.value = j.text.trim();
          toast('Heard: ' + j.text);
          try { await startSearch(true); } catch (e) { console.error(e); }
        } else {
          toast('Could not transcribe');
        }
      };
      mediaRecorder.start();
      hint.textContent = 'Listening... release to stop';
    };

    const stopRecording = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        hint.textContent = '';
      }
    };

    // Mouse events (desktop)
    btnVoice.onmousedown = startRecording;
    btnVoice.onmouseup = stopRecording;
    btnVoice.onmouseleave = stopRecording;
    // Touch events (mobile)
    btnVoice.ontouchstart = (e) => { e.preventDefault(); startRecording(); };
    btnVoice.ontouchend = (e) => { e.preventDefault(); stopRecording(); };

    // --- Product search (Gemini + Google PSE) + fal compose ---
    const btnFind = document.getElementById('btnFind');
    const desc = document.getElementById('desc');
    const budget = document.getElementById('budget');
    // zip removed
    const toggleImages = document.getElementById('toggleImages');
    const refineSection = document.getElementById('refineSection');
    const refineInput = document.getElementById('refineInput');
    const btnRefine = document.getElementById('btnRefine');

    let latestCompose = { lowUrl: null, midUrl: null, highUrl: null };
    let lastSearch = { description: '', budget: 150, image: true };
    let lastIsoUrl = null;
    let composeBaseUrl = null; // when set, compose uses existing composite instead of original room photo

    async function startSearch(fromVoice = false) {
      const useImages = !!toggleImages.checked;
      const description = desc.value || 'home decor';
      const b = Number(budget.value || 150);
      if (useImages && !spaceBlob && !composeBaseUrl) return toast('Take or upload a room photo first');
      setLoading(true, 'Searching products...');
      const r = await fetch('/api/products', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ description, budget: b, image: useImages })
      });
      const data = await r.json();
      if (!r.ok) return toast('Search error: ' + (data.error || 'unknown'));
      lastSearch = { description, budget: b, image: useImages };

      // Build tier image sets for fal compose and remember which product items are used per tier
      const tiers = { low: [], mid: [], high: [] };
      const singleType = data.intent && data.intent.specific && !data.intent.general;
      const perTierMax = singleType ? 1 : 5;
      tierProductsUsed = { low: [], mid: [], high: [] };
      const seenGlobal = new Set();
      for (const k of ['low','mid','high']) {
        const items = data[k] || [];
        const seen = seenGlobal;
        const unique = [];
        for (const it of items) {
          const key = it.url || it.image || it.title;
          if (!key || seen.has(key)) continue;
          seen.add(key);
          unique.push(it);
          if (unique.length >= perTierMax) break;
        }
        const imageSet = new Set();
        tiers[k] = [];
        unique.forEach(item => { if (item.image && !imageSet.has(item.image)) { tiers[k].push(item.image); imageSet.add(item.image); } });
        tierProductsUsed[k] = unique;
      }

      // If triggered by voice input, request a concise philosophy per tier
      philosophyByTier = null;
      if (fromVoice) {
        try {
          const payload = {
            description,
            budget: b,
            tiers: {
              low: tierProductsUsed.low.map(p => ({ title: p.title, price: p.price, currency: p.currency, url: p.url, source: p.source })),
              mid: tierProductsUsed.mid.map(p => ({ title: p.title, price: p.price, currency: p.currency, url: p.url, source: p.source })),
              high: tierProductsUsed.high.map(p => ({ title: p.title, price: p.price, currency: p.currency, url: p.url, source: p.source })),
            },
          };
          const pr = await fetch('/api/philosophy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          const pj = await pr.json();
          if (pr.ok) philosophyByTier = pj;
        } catch (e) { console.warn('philosophy error', e); }
      }

      // If images disabled -> only list products
      if (!useImages) {
        setLoading(false);
        renderProductList(data);
        openDrawer();
        return;
      }

      // compose with fal nano-banana/edit
      const fd = new FormData();
      if (composeBaseUrl) fd.append('baseImageUrl', composeBaseUrl);
      else fd.append('space', spaceBlob, 'space.jpg');
      const intent = data.intent || {};
      const composeNote = (intent.specific && !intent.general)
        ? ` Only include ${intent.specific}(s); do not add unrelated items. Include all referenced products.`
        : ` Combine suitable items for this tier; include all referenced products together.`;
      fd.append('prompt', `Add only the referenced products to this exact room without changing the background or existing elements. Do not modify or remove any existing furniture, decor, walls, windows, floor, ceiling, or lighting. Preserve original style, layout, colors, materials, geometry, and camera perspective; maintain natural lighting and scale. Include every provided product exactly once; no duplicates, no substitutions, no omissions.${composeNote}`);
      fd.append('productsJson', JSON.stringify(tiers));
      setLoading(true, 'Compositing visuals...');
      const fr = await fetch('/api/fal/compose', { method: 'POST', body: fd });
      const j = await fr.json();
      setLoading(false);
      if (!fr.ok) return toast('fal compose error: ' + (j.error || 'unknown'));

      latestCompose = j;
      // Show overlay and bottom bar
      selectedTier = j.highUrl ? 'high' : (j.midUrl ? 'mid' : 'low');
      updateCompositeView(selectedTier);
      document.getElementById('compositeOverlay').classList.remove('hidden');
      // Ensure camera hidden when showing composites
      stopCam();
      video.classList.add('hidden');
      showControlsUI();
      renderProductList(data); // keep drawer for product-only browsing
      // Show refine controls now that we have results
      refineSection.classList.remove('hidden');
    }

    btnFind.onclick = startSearch;

    function showDrawer({ lowUrl, midUrl, highUrl }) {
      const box = document.getElementById('images');
      box.innerHTML = '';
      for (const [tier, url] of [['Low',lowUrl],['Mid',midUrl],['High',highUrl]]) {
        const el = document.createElement('div');
        el.className = 'rounded-xl overflow-hidden bg-white/5';
        el.innerHTML = `<div class="p-2 text-sm opacity-80">${tier}</div><img class="w-full" src="${url}" />`;
        box.appendChild(el);
      }
      openDrawer();
    }

    // Render product lists by tier
    function renderProductList(data) {
      const wrapId = 'productList';
      let wrap = document.getElementById(wrapId);
      if (!wrap) {
        const drawer = document.getElementById('drawer');
        const section = document.createElement('div');
        section.className = 'mt-6';
        section.innerHTML = `<div class=\"flex items-center justify-between\"><h3 class=\"text-lg font-medium\">Products</h3></div><div id=\"philosophy\" class=\"mt-2 space-y-2\"></div><div id=\"${wrapId}\" class=\"mt-3 space-y-4\"></div>`;
        drawer.appendChild(section);
        wrap = section.querySelector('#' + wrapId);
      }

      // Render philosophy card if present
      const ph = document.getElementById('philosophy');
      if (ph) {
        ph.innerHTML = '';
        if (philosophyByTier && (philosophyByTier.low || philosophyByTier.mid || philosophyByTier.high)) {
          const card = document.createElement('div');
          card.className = 'p-3 rounded-xl bg-white/5';
          const row = (label, text) => text ? `<div class=\"mb-1\"><span class=\"text-xs opacity-70\">${label}:</span> <span class=\"text-sm\">${text}</span></div>` : '';
          card.innerHTML = `${row('Low', philosophyByTier.low)}${row('Mid', philosophyByTier.mid)}${row('High', philosophyByTier.high)}`;
          ph.appendChild(card);
        }
      }

      const tiers = [
        ['Low', data.low || []],
        ['Mid', data.mid || []],
        ['High', data.high || []],
      ];
      wrap.innerHTML = '';
      for (const [label, items] of tiers) {
        const box = document.createElement('div');
        box.innerHTML = `<div class="text-sm opacity-80 mb-1">${label}</div>`;
        const list = document.createElement('div');
        list.className = 'grid gap-2';
        const arr = items || [];
        if (!arr.length) {
          const empty = document.createElement('div');
          empty.className = 'text-xs opacity-60 italic';
          empty.textContent = 'No items found in this range';
          list.appendChild(empty);
        }
        arr.forEach(p => {
          const row = document.createElement('a');
          row.className = 'flex items-center gap-3 p-2 rounded-xl bg-white/5 hover:bg-white/10';
          row.href = p.url;
          row.target = '_blank';
          row.rel = 'noopener';
          const img = p.image ? `<img src="${p.image}" alt="${p.title || 'product'}" class="w-16 h-16 object-cover rounded"/>` : '';
          const price = (p.price != null) ? `${p.currency || 'USD'} $${p.price}` : '';
          const desc = p.description ? `<div class="text-xs opacity-70 max-h-10 overflow-hidden">${p.description}</div>` : '';
          const currency = p.currency ? `${p.currency} ` : '';
          row.innerHTML = `${img}<div class="min-w-0"><div class="truncate text-sm">${p.title || 'Product'}</div><div class="text-xs opacity-70 truncate">${p.source || ''}</div>${desc}</div><div class="ml-auto text-sm">${currency}${price}</div>`;
          list.appendChild(row);
        });
        box.appendChild(list);
        wrap.appendChild(box);
      }
    }

    // tier buttons to switch overlay image
    function updateCompositeView(tier) {
      const url = latestCompose[`${tier}Url`];
      const img = document.getElementById('compositeImg');
      if (url) {
        img.src = url;
        selectedTier = tier;
      }
    }
    document.querySelectorAll('.tierBtn').forEach(btn => btn.onclick = () => {
      const t = btn.dataset.tier;
      updateCompositeView(t);
    });

    // finalize -> isometric + 3D
    const finalizeBtn = document.getElementById('finalize') || document.getElementById('finalizeDrawer');
    if (finalizeBtn) finalizeBtn.onclick = async () => {
      const url = (selectedTier && latestCompose[`${selectedTier}Url`]) || latestCompose.highUrl || latestCompose.midUrl || latestCompose.lowUrl;
      if (!url) return toast('Nothing to finalize');
      setLoading(true, 'Finalizing...');
      const r = await fetch('/api/fal/finalize', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ selectedImageUrl: url, selectedTier, tierTitles: (tierProductsUsed[selectedTier]||[]).map(p=>p.title).filter(Boolean) })
      });
      const j = await r.json();
      setLoading(false);
      if (!r.ok) return toast('Finalize error: ' + (j.error || 'unknown'));

      const box = document.getElementById('images');
      box.innerHTML = '';
      box.insertAdjacentHTML('beforeend', `<div class='rounded-xl overflow-hidden bg-white/5'><div class='p-2 text-sm opacity-80'>Isometric</div><img class='w-full' src='${j.isoImageUrl}'/></div>`);
      lastIsoUrl = j.isoImageUrl || null;
      // Add Show in 3D button
      const show3dBtnId = 'btnShow3D';
      const old = document.getElementById(show3dBtnId);
      if (old) old.remove();
      const show3d = document.createElement('button');
      show3d.id = show3dBtnId;
      show3d.className = 'px-3 py-1.5 mt-2 rounded-xl bg-white/10 text-sm';
      show3d.textContent = 'Show in 3D';
      show3d.onclick = async () => {
        if (!lastIsoUrl) return toast('No isometric view to convert');
        setLoading(true, 'Generating 3D...');
        const tr = await fetch('/api/fal/3d', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ imageUrl: lastIsoUrl }) });
        const tj = await tr.json();
        setLoading(false);
        if (!tr.ok) return toast('3D error: ' + (tj.error || 'unknown'));
        const glbUrl = tj.proxyUrl || tj.glbUrl;
        console.log('3D model URL:', tj.glbUrl);
        if (!glbUrl) return toast('No 3D model');
        const mv = document.getElementById('modelViewer');
        mv.src = glbUrl;
        document.getElementById('modelModal').classList.remove('hidden');
      };
      box.appendChild(show3d);
      openDrawer();
    };

    // Reorganize current tier: preserve existing items, reposition layout to fit new items
    const reorgBtn = document.getElementById('reorganizeDrawer');
    if (reorgBtn) reorgBtn.onclick = async () => {
      if (!selectedTier) return toast('Select a tier first');
      if (!spaceBlob) return toast('Take or upload a room photo first');
      const fd = new FormData();
      if (composeBaseUrl) fd.append('baseImageUrl', composeBaseUrl);
      else fd.append('space', spaceBlob, 'space.jpg');
      const tiers = { low: [], mid: [], high: [] };
      const images = new Set();
      (tierProductsUsed[selectedTier] || []).forEach(p => { if (p.image && !images.has(p.image)) { tiers[selectedTier].push(p.image); images.add(p.image); } });
      fd.append('productsJson', JSON.stringify(tiers));
      fd.append('tier', selectedTier);
      setLoading(true, 'Reorganizing layout...');
      const rr = await fetch('/api/fal/reorganize', { method: 'POST', body: fd });
      const rj = await rr.json();
      setLoading(false);
      if (!rr.ok) return toast('Reorganize error: ' + (rj.error || 'unknown'));
      // Show reorganized image as the current overlay and add to drawer
      const url = rj.reorgUrl;
      if (url) {
        const img = document.getElementById('compositeImg');
        img.src = url;
        document.getElementById('compositeOverlay').classList.remove('hidden');
        stopCam();
        video.classList.add('hidden');
        const box = document.getElementById('images');
        box.insertAdjacentHTML('afterbegin', `<div class='rounded-xl overflow-hidden bg-white/5'><div class='p-2 text-sm opacity-80'>Reorganized (${selectedTier.toUpperCase()})</div><img class='w-full' src='${url}'/></div>`);
        openDrawer();
      }
    };

    // Composite image click -> show product modal for that tier
    document.getElementById('compositeImg').onclick = () => {
      if (!selectedTier) return;
      const list = tierProductsUsed[selectedTier] || [];
      const body = document.getElementById('productModalBody');
      body.innerHTML = '';
      list.forEach(p => {
        const a = document.createElement('a');
        a.href = p.url;
        a.target = '_blank';
        a.rel = 'noopener';
        a.className = 'flex items-center gap-3 p-2 rounded-xl bg-white/5 hover:bg-white/10';
        const img = p.image ? `<img src="${p.image}" class="w-14 h-14 object-cover rounded"/>` : '';
        const price = p.price != null ? `${p.currency || 'USD'} $${p.price}` : '';
        a.innerHTML = `${img}<div class="min-w-0"><div class="truncate text-sm">${p.title || 'Product'}</div><div class="text-xs opacity-70 truncate">${p.source || ''}</div></div><div class="ml-auto text-sm">${price}</div>`;
        body.appendChild(a);
      });
      document.getElementById('productModalTitle').textContent = selectedTier.toUpperCase() + ' Products';
      document.getElementById('productModal').classList.remove('hidden');
    };
    document.getElementById('productModalClose').onclick = () => document.getElementById('productModal').classList.add('hidden');
    document.getElementById('productModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('productModal')) document.getElementById('productModal').classList.add('hidden');
    });

    // drawer controls
    const drawer = document.getElementById('drawer');
    const drawerOpen = document.getElementById('drawerOpen');
    const drawerClose = document.getElementById('drawerClose');
    const openDrawer = () => drawer.classList.remove('closed');
    const closeDrawer = () => drawer.classList.add('closed');
    drawerOpen.onclick = openDrawer;
    drawerClose.onclick = closeDrawer;

    // drag-to-open/close (basic)
    let startX = null;
    drawerOpen.addEventListener('touchstart', (e) => { startX = e.touches[0].clientX; });
    drawerOpen.addEventListener('touchmove', (e) => {
      if (startX == null) return;
      const dx = e.touches[0].clientX - startX;
      if (dx < -40) openDrawer();
    });
    drawer.addEventListener('touchstart', (e) => { startX = e.touches[0].clientX; });
    drawer.addEventListener('touchmove', (e) => {
      if (startX == null) return;
      const dx = e.touches[0].clientX - startX;
      if (dx > 60) closeDrawer();
    });

    // tiny toast (fixed syntax)
    function toast(msg) {
      const d = document.createElement('div');
      d.textContent = msg;
      d.className = 'fixed bottom-4 left-1/2 -translate-x-1/2 bg-white text-black px-3 py-2 rounded-xl shadow';
      document.body.appendChild(d);
      setTimeout(() => d.remove(), 1800);
    }

    function setLoading(on, text) {
      const el = document.getElementById('loading');
      const t = document.getElementById('loadingText');
      if (typeof text === 'string') t.textContent = text;
      if (on) {
        el.classList.remove('hidden');
        el.classList.add('flex');
      } else {
        el.classList.add('hidden');
        el.classList.remove('flex');
      }
    }

    // Bottom bar controls
    document.getElementById('btnCamera').onclick = () => {
      // Reset overlay for a new snap
      document.getElementById('compositeOverlay').classList.add('hidden');
      document.getElementById('bottomBar').classList.add('hidden');
      latestCompose = { lowUrl: null, midUrl: null, highUrl: null };
      selectedTier = null;
      tierProductsUsed = { low: [], mid: [], high: [] };
      startCam();
    };

    // Add more / Start new (after first images)
    // Buttons are added to the bottom bar near tier toggles
    const bar = document.querySelector('#bottomBar .flex.items-center.gap-2');
    if (bar) {
      const wrap = document.createElement('div');
      wrap.className = 'flex gap-2 ml-2';
      wrap.innerHTML = `<button id="btnAddMore" class="px-3 py-2 rounded-xl bg-white/10">Add more</button><button id="btnStartNew" class="px-3 py-2 rounded-xl bg-white/10">Start new</button>`;
      bar.appendChild(wrap);
      const btnAddMore = document.getElementById('btnAddMore');
      const btnStartNew = document.getElementById('btnStartNew');
      btnAddMore.onclick = () => {
        const url = (selectedTier && latestCompose[`${selectedTier}Url`]) || latestCompose.highUrl || latestCompose.midUrl || latestCompose.lowUrl;
        if (!url) return toast('No current image to extend');
        composeBaseUrl = url;
        toast('Will add to current image. Use Refine to specify what to add.');
      };
      btnStartNew.onclick = () => {
        composeBaseUrl = null;
        latestCompose = { lowUrl: null, midUrl: null, highUrl: null };
        selectedTier = null;
        tierProductsUsed = { low: [], mid: [], high: [] };
        if (spaceBlob) {
          const url = URL.createObjectURL(spaceBlob);
          const img = document.getElementById('compositeImg');
          img.src = url;
          document.getElementById('compositeOverlay').classList.remove('hidden');
          stopCam(); video.classList.add('hidden');
          toast('Starting new with original photo');
        } else {
          // No photo yet â€“ restart camera
          document.getElementById('compositeOverlay').classList.add('hidden');
          startCam();
          toast('Starting new');
        }
      };
    }

    // Voice button in bottom bar mirrors main voice control
    const btnVoiceBar = document.getElementById('btnVoiceBar');
    btnVoiceBar.onmousedown = btnVoice.onmousedown;
    btnVoiceBar.onmouseup = btnVoice.onmouseup;
    btnVoiceBar.onmouseleave = btnVoice.onmouseleave;
    btnVoiceBar.ontouchstart = (e) => { e.preventDefault(); btnVoice.onmousedown(); };
    btnVoiceBar.ontouchend = (e) => { e.preventDefault(); btnVoice.onmouseup(); };

    // Show bottom bar when overlay is active
    function showControlsUI() {
      document.getElementById('bottomBar').classList.remove('hidden');
    }
    // 3D modal close handlers
    document.getElementById('modelModalClose').onclick = () => document.getElementById('modelModal').classList.add('hidden');
    document.getElementById('modelModal').addEventListener('click', (e) => {
      if (e.target === document.getElementById('modelModal')) document.getElementById('modelModal').classList.add('hidden');
    });

    // --- Refinement flow ---
    function parseRefine(text) {
      const t = (text || '').toLowerCase();
      const categories = [];
      const addCat = (name, bias=null) => categories.push({ name, bias });
      const has = (w) => t.includes(w);
      const catWords = {
        shelving: ['shelf','shelving','bookcase','bookshelf'],
        lamp: ['lamp','floor lamp','table lamp','lighting','light'],
        rug: ['rug','area rug'],
        sofa: ['sofa','couch','sectional'],
        table: ['table','coffee table','side table','end table','console table'],
      };
      const allCats = Object.keys(catWords);
      // heuristic: capture phrases like 'cheaper shelving', 'pricier lamp', 'more expensive lamp'
      allCats.forEach(cat => {
        const any = catWords[cat].some(w => has(w));
        if (any) addCat(cat);
      });
      const cheaper = /(cheaper|less expensive|lower|budget)/i.test(text);
      const pricier = /(pricier|more expensive|higher|upgrade)/i.test(text);
      if (cheaper || pricier) {
        categories.forEach(c => { c.bias = cheaper ? 'low' : 'high'; });
        // category-specific bias: e.g., 'cheaper shelving' should only apply to shelving
        Object.entries(catWords).forEach(([cat, words]) => {
          if (new RegExp(`(cheaper|less expensive|lower)\s+(${words.map(w=>w.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')).join('|')})`, 'i').test(text)) {
            const idx = categories.findIndex(c => c.name === cat);
            if (idx >= 0) categories[idx].bias = 'low'; else categories.push({ name: cat, bias: 'low' });
          }
          if (new RegExp(`(pricier|more expensive|higher|upgrade)\s+(${words.map(w=>w.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')).join('|')})`, 'i').test(text)) {
            const idx = categories.findIndex(c => c.name === cat);
            if (idx >= 0) categories[idx].bias = 'high'; else categories.push({ name: cat, bias: 'high' });
          }
        });
      }
      let budgetShift = 1;
      if (/(higher budget|increase budget|more expensive overall|upgrade overall)/i.test(text)) budgetShift = 1.3;
      if (/(lower budget|decrease budget|cheaper overall|reduce overall)/i.test(text)) budgetShift = 0.8;
      return { categories, budgetShift };
    }

    async function refineSearch() {
      const txt = refineInput.value.trim();
      if (!txt) return toast('Type how to refine');
      const { categories, budgetShift } = parseRefine(txt);
      const newBudget = Math.max(10, Math.round((lastSearch.budget || 150) * budgetShift));
      const useImages = lastSearch.image;
      if (useImages && !spaceBlob && !composeBaseUrl) return toast('Take or upload a room photo first');
      setLoading(true, 'Refining...');
      const r = await fetch('/api/products', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ description: `${lastSearch.description}. ${txt}`, budget: newBudget, image: useImages }) });
      const data = await r.json();
      setLoading(false);
      if (!r.ok) return toast('Refine error: ' + (data.error || 'unknown'));

      // Build merged tiers: keep previous items + add category-matched items from chosen tiers
      const perTierMax = 5;
      const catMatch = (p, cat) => {
        const s = `${p.title || ''} ${p.description || ''}`.toLowerCase();
        const dict = { shelving: ['shelf','shelving','bookcase','bookshelf'], lamp: ['lamp','lighting','light'], rug: ['rug'], sofa: ['sofa','couch','sectional'], table: ['table','coffee','side','console'] };
        return (dict[cat] || []).some(w => s.includes(w));
      };
      const tiers = { low: [], mid: [], high: [] };
      const newSets = { low: data.low || [], mid: data.mid || [], high: data.high || [] };
      // Start from previous used
      const mergedUsed = { low: [...(tierProductsUsed.low||[])], mid: [...(tierProductsUsed.mid||[])], high: [...(tierProductsUsed.high||[])] };
      const seen = new Set([...(mergedUsed.low||[]),...(mergedUsed.mid||[]),...(mergedUsed.high||[])].map(p => p.url || p.image || p.title));

      for (const k of ['low','mid','high']) {
        const list = mergedUsed[k] || [];
        // Add matched categories with bias
        categories.forEach(({ name, bias }) => {
          const sourceTier = bias === 'low' ? 'low' : (bias === 'high' ? 'high' : k);
          const src = newSets[sourceTier] || [];
          for (const p of src) {
            if (list.length >= perTierMax) break;
            const key = p.url || p.image || p.title;
            if (!key || seen.has(key)) continue;
            if (!catMatch(p, name)) continue;
            list.push(p); seen.add(key);
          }
        });
        // Fill up with general items from the same tier
        for (const p of (newSets[k] || [])) {
          if (list.length >= perTierMax) break;
          const key = p.url || p.image || p.title;
          if (!key || seen.has(key)) continue;
          list.push(p); seen.add(key);
        }
        // Convert to image URLs for compose
        const images = new Set();
        tiers[k] = [];
        list.forEach(p => { if (p.image && !images.has(p.image)) { tiers[k].push(p.image); images.add(p.image); } });
        mergedUsed[k] = list;
      }
      tierProductsUsed = mergedUsed;

      // Compose again with merged products
      if (!useImages) { renderProductList(data); openDrawer(); return; }
      const fd = new FormData();
      if (composeBaseUrl) fd.append('baseImageUrl', composeBaseUrl);
      else fd.append('space', spaceBlob, 'space.jpg');
      fd.append('prompt', 'Add only the referenced products to this exact room without changing the background or existing elements. Do not modify or remove any existing furniture, decor, walls, windows, floor, ceiling, or lighting. Preserve original style, layout, colors, materials, geometry, and camera perspective; maintain natural lighting and scale. Include every provided product exactly once; no duplicates, no substitutions, no omissions.');
      fd.append('productsJson', JSON.stringify(tiers));
      setLoading(true, 'Updating visuals...');
      const fr = await fetch('/api/fal/compose', { method: 'POST', body: fd });
      const j = await fr.json();
      setLoading(false);
      if (!fr.ok) return toast('Compose error: ' + (j.error || 'unknown'));
      latestCompose = j;
      selectedTier = selectedTier || (j.highUrl ? 'high' : (j.midUrl ? 'mid' : 'low'));
      updateCompositeView(selectedTier);
      document.getElementById('compositeOverlay').classList.remove('hidden');
      stopCam(); video.classList.add('hidden');
      showControlsUI();
      renderProductList(data);
    }
    btnRefine.onclick = refineSearch;
  </script>
</body>
</html>
